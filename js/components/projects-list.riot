<!--Parent component that handles logic for gathering data-->
<projects-list>
    <p if={this.state.loading}>Loading...</p>
    <template if={!this.state.loading && !this.state.error}>
        <search search={this.search}></search>
        <div style="display: flex; justify-content: space-between; align-items: flex-end;">
            <p 
                class="vf-text-body vf-text-body--3"
                if={this.state.data}
                >
                    Showing <strong>{this.state.data.length}</strong> results
                </p>
        </div>
        <data-table 
            data={this.state.data}
            setSort={this.setSort}
            sort={this.state.sort}
            dataLocations={this.ALLOWED_DATA__LOCATIONS}
            organNames={this.organNames}
            technologyNames={this.technologyNames}
            setFilters={this.setFilters}
            if={this.state.data}
        ></data-table>
    </template>
    <template if={this.state.error}>
        <div style="text-align: center;">
            <h1>Something went wrong</h1>
            <p>Please try refreshing the page.</p>
        </div>
    </template>

    <script>
        import DataTable from "./table.riot";
        import Search from "./search.riot";
        import resolve from "../resolver";
        import compose from "lodash/fp/compose";
        import flatten from "lodash/flatten";
        import uniq from "lodash/uniq";
        import defaults from "lodash/defaults";

        export default {
            onMounted() {
                this.ALLOWED_DATA__LOCATIONS = ["HCA Data Portal", "GEO", "ENA", "ArrayExpress", "EGA"];
                this.FEEDBACK_EMAIL = process.env.FEEDBACK_EMAIL;
                this.ADD_PROJECT_SUBJECT = process.env.ADD_PROJECT_SUBJECT;
                this.update({ data: [], loading: true })

                resolve().then(data => {
                    this.organNames = uniq(flatten(data.map(dataPoint => dataPoint.organ_names)));
                    this.technologyNames = uniq(flatten(data.map(dataPoint => dataPoint.technology_names)));

                    this.update({
                        unfilteredData: data,
                        data: data,
                        sort: {
                            timestampDesc: true
                        },
                        filters: {
                            organName: "",
                            technologyName: "",
                            dataLocation: ""
                        },
                        dataLocation: [],
                        searchVal: "",
                        loading: false
                    });
                }).catch(e => {
                    console.error(e);
                    this.update({
                        error: true,
                        loading: false
                    })
                })
            },
            getSorted: ({ timestampDesc }) => data => {
                // Arrow function as this is "static" (pure function) and should not change state
                if (timestampDesc) {
                    return data.sort((a, b) => a.added_to_index <= b.added_to_index ? 1 : -1);
                }
                return data.sort((a, b) => a.added_to_index <= b.added_to_index ? -1 : 1);
            },
            getFilteredBySearch: (val = "") => data => {
                return data.filter(
                    dataPoint => [                             
                            dataPoint["contributors"].map(contributor => contributor.name).join(", "),
                            dataPoint["uuid"],
                            dataPoint["project_core"]["project_title"],
                            dataPoint["insdc_project_accessions"].join(" "),
                            dataPoint["array_express_accessions"].join(" "),
                            dataPoint["ega_studies_accessions"].join(" "),
                            dataPoint["ega_datasets_accessions"].join(" "),
                            dataPoint["geo_series_accessions"].join(" "),
                            dataPoint["organ_names"].join(" "),
                            dataPoint["technology_names"].join(" ")
                        ].map(x => x.toLowerCase()).join(" ").includes(val.toLowerCase())
                );
            },
            getFiltered: ({ organName, technologyName, dataLocation }) => data => {
                let filteredData = data
                    .filter(dataPoint => organName ? dataPoint.organ_names.includes(organName) : true)
                    .filter(dataPoint => technologyName ? dataPoint.technology_names.includes(technologyName): true);

                switch(dataLocation) {
                    case "HCA Data Portal":
                        return filteredData.filter(dataPoint => !!dataPoint["dcp_url"]);
                    case "GEO":
                        return filteredData.filter(dataPoint => dataPoint["geo_series_accessions"].length);
                    case "ArrayExpress":
                        return filteredData.filter(dataPoint => dataPoint["array_express_accessions"].length);
                    case "ENA":
                        return filteredData.filter(dataPoint => dataPoint["insdc_project_accessions"].length);
                    case "EGA":
                        return filteredData.filter(dataPoint => dataPoint["ega_studies_accessions"].length || dataPoint["ega_datasets_accessions"].length);
                    default:
                        return filteredData;
                }
            },
            applyFiltering() {
                const data = compose(
                    this.getSorted(this.state.sort),
                    this.getFilteredBySearch(this.state.searchVal),
                    this.getFiltered(this.state.filters)
                )(this.state.unfilteredData);
                this.update({
                    data
                });
            },
            search(val) {
                this.update({
                    searchVal: val,
                });
                this.applyFiltering();

                const LIMIT = 5;

                window.dataLayer.push({
                    event: "search_projects",
                    search_term: val,
                    search_projects_term_and_uuids: `term: ${val}, results: ${this.state.data.slice(0, LIMIT).map(dataPoint => dataPoint.uuid).join(",")}`,
                    search_projects_term_and_titles: `term: ${val}, results: ${this.state.data.slice(0, LIMIT).map(dataPoint => dataPoint.project_core.project_title).join(",")}`,
                });
            },
            setFilters({ organName, technologyName, dataLocation }) {
                this.update({
                    filters: defaults({ organName, technologyName, dataLocation}, this.state.filters)
                });
                this.applyFiltering();
            },
            setSort(sortBy) {
                this.update({
                    sort: sortBy,
                });
                this.applyFiltering()
            },
            components: {
                DataTable,
                Search
            }
        }
    </script>
</projects-list>